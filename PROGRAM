# Professional Work Monitoring System - Popup-as-subprocess fix
# Popups are launched as independent subprocesses so they appear even when main window is minimized.
# Requirements: opencv-python, mediapipe, Pillow, pygame, scipy

import cv2
import numpy as np
import time
from datetime import datetime
import tkinter as tk
from tkinter import ttk, messagebox
from PIL import Image, ImageTk
import threading
import mediapipe as mp
from scipy.spatial import distance as dist
import pygame
import os
import traceback
import sys
import subprocess
import tempfile
import shlex

# ---------------------------
# SETTINGS WINDOW (UNCHANGED)
# ---------------------------
class ProfessionalSettingsWindow:
    def _init_(self):
        self.root = tk.Tk()
        self.root.title("WORK MONITORING SYSTEM - CONTROL PANEL")
        self.root.geometry("900x750")
        self.root.resizable(False, False)
        self.root.configure(bg="#1e2a38")
        self.setup_styles()
        self.config = None
        self.setup_ui()

    def setup_styles(self):
        style = ttk.Style()
        try:
            style.theme_use('clam')
        except Exception:
            pass
        style.configure('Professional.TFrame', background='#1e2a38')
        style.configure('Header.TLabel', background='#1e2a38', foreground='white', font=('Arial', 16, 'bold'))
        style.configure('Subheader.TLabel', background='#2c3e50', foreground='white', font=('Arial', 12, 'bold'))
        style.configure('Card.TFrame', background='#2c3e50', relief='raised', borderwidth=1)

    def setup_ui(self):
        main_container = ttk.Frame(self.root, style='Professional.TFrame')
        main_container.pack(fill='both', expand=True, padx=20, pady=20)

        header_frame = ttk.Frame(main_container, style='Professional.TFrame')
        header_frame.pack(fill='x', pady=(0, 20))

        ttk.Label(header_frame, text="üè≠ WORK MONITORING SYSTEM",
                  style='Header.TLabel').pack(side=tk.LEFT)

        ttk.Label(header_frame, text="CONTROL PANEL v2.0",
                  style='Header.TLabel', foreground='#3498db').pack(side=tk.RIGHT)

        notebook = ttk.Notebook(main_container)
        notebook.pack(fill='both', expand=True)

        quick_frame = ttk.Frame(notebook, style='Professional.TFrame')
        notebook.add(quick_frame, text="üöÄ QUICK START")
        self.setup_quick_tab(quick_frame)

        advanced_frame = ttk.Frame(notebook, style='Professional.TFrame')
        notebook.add(advanced_frame, text="‚öô ADVANCED SETTINGS")
        self.setup_advanced_tab(advanced_frame)

        self.setup_status_panel(main_container)

    def setup_quick_tab(self, parent):
        presets_container = ttk.Frame(parent, style='Professional.TFrame')
        presets_container.pack(fill='both', expand=True, padx=10, pady=10)

        ttk.Label(presets_container, text="SELECT WORK PROFILE:",
                  style='Subheader.TLabel').pack(anchor='w', pady=(0, 15))

        presets = [
            {"name": "‚ö° QUICK FOCUS", "work": 25, "rest": 5, "prep": 1, "work_unit": "minutes", "rest_unit": "minutes",
             "desc": "Ideal for short tasks and quick breaks", "color": "#e74c3c", "icon": "‚ö°"},
            {"name": "üíº STANDARD WORK", "work": 45, "rest": 10, "prep": 2, "work_unit": "minutes", "rest_unit": "minutes",
             "desc": "Balanced work-rest cycle for office work", "color": "#3498db", "icon": "üíº"},
            {"name": "üöÄ DEEP WORK", "work": 50, "rest": 10, "prep": 2, "work_unit": "minutes", "rest_unit": "minutes",
             "desc": "Extended focus sessions with adequate breaks", "color": "#9b59b6", "icon": "üöÄ"},
            {"name": "üéØ POMODORO PRO", "work": 25, "rest": 5, "prep": 1, "work_unit": "minutes", "rest_unit": "minutes",
             "desc": "Classic Pomodoro technique for productivity", "color": "#2ecc71", "icon": "üéØ"},
            {"name": "üìä LONG SESSION", "work": 90, "rest": 15, "prep": 3, "work_unit": "minutes", "rest_unit": "minutes",
             "desc": "Extended sessions for complex tasks", "color": "#f39c12", "icon": "üìä"}
        ]

        self.preset_var = tk.StringVar(value=presets[0]["name"])
        for i, preset in enumerate(presets):
            card = self.create_preset_card(presets_container, preset, i)
            card.pack(fill='x', pady=5)

    def create_preset_card(self, parent, preset, index):
        card = tk.Frame(parent, bg='#34495e', relief='raised', bd=1)
        rb = tk.Radiobutton(card, text="", variable=self.preset_var,
                            value=preset["name"], bg='#34495e', fg='white',
                            selectcolor='#2c3e50', command=lambda p=preset: self.show_preset_details(p))
        rb.pack(side=tk.LEFT, padx=10)
        icon_label = tk.Label(card, text=preset["icon"], font=('Arial', 16),
                              bg='#34495e', fg=preset["color"])
        icon_label.pack(side=tk.LEFT, padx=5)
        text_frame = tk.Frame(card, bg='#34495e')
        text_frame.pack(side=tk.LEFT, fill='x', expand=True, padx=5, pady=8)
        name_label = tk.Label(text_frame, text=preset["name"],
                              font=('Arial', 11, 'bold'), bg='#34495e', fg='white')
        name_label.pack(anchor='w')
        desc_label = tk.Label(text_frame, text=preset["desc"],
                              font=('Arial', 9), bg='#34495e', fg='#bdc3c7')
        desc_label.pack(anchor='w')
        work_unit_symbol = "m" if preset["work_unit"] == "minutes" else "h" if preset["work_unit"] == "hours" else "s"
        rest_unit_symbol = "m" if preset["rest_unit"] == "minutes" else "h" if preset["rest_unit"] == "hours" else "s"
        time_label = tk.Label(card,
                              text=f"‚è± {preset['work']}{work_unit_symbol} work ‚Üí {preset['rest']}{rest_unit_symbol} break",
                              font=('Arial', 9), bg='#34495e', fg='#3498db')
        time_label.pack(side=tk.RIGHT, padx=10)
        return card

    def setup_advanced_tab(self, parent):
        container = tk.Frame(parent, bg='#1e2a38')
        container.pack(fill='both', expand=True)
        canvas = tk.Canvas(container, bg='#1e2a38', highlightthickness=0)
        scrollbar = ttk.Scrollbar(container, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#1e2a38')
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        self.work_value_var = tk.IntVar(value=10)
        self.work_unit_var = tk.StringVar(value="seconds")
        self.rest_value_var = tk.IntVar(value=20)
        self.rest_unit_var = tk.StringVar(value="seconds")
        self.prep_value_var = tk.IntVar(value=10)
        self.prep_unit_var = tk.StringVar(value="seconds")

        work_card = self.create_setting_card(scrollable_frame, "‚è∞ WORK SETTINGS", 0)
        tk.Label(work_card, text="Work Duration:",
                 font=('Arial', 10, 'bold'), bg='#2c3e50', fg='white').pack(anchor='w', pady=(10, 5))
        work_time_frame = tk.Frame(work_card, bg='#2c3e50')
        work_time_frame.pack(fill='x', padx=10, pady=5)
        work_value_frame = tk.Frame(work_time_frame, bg='#2c3e50')
        work_value_frame.pack(side=tk.LEFT)
        tk.Label(work_value_frame, text="Duration:",
                 font=('Arial', 9), bg='#2c3e50', fg='white').pack(anchor='w')
        work_scale = tk.Scale(work_value_frame, from_=1, to=120, orient=tk.HORIZONTAL,
                              variable=self.work_value_var, length=200, bg='#2c3e50', fg='white',
                              highlightthickness=0, sliderlength=20)
        work_scale.pack(fill='x', pady=5)
        work_entry = tk.Entry(work_value_frame, textvariable=self.work_value_var, width=5, font=('Arial', 10))
        work_entry.pack(pady=5)
        work_unit_frame = tk.Frame(work_time_frame, bg='#2c3e50')
        work_unit_frame.pack(side=tk.RIGHT, padx=20)
        tk.Label(work_unit_frame, text="Unit:", font=('Arial', 9), bg='#2c3e50', fg='white').pack(anchor='w')
        work_unit_combo = ttk.Combobox(work_unit_frame, textvariable=self.work_unit_var,
                                       values=["seconds", "minutes", "hours"], state="readonly", width=10)
        work_unit_combo.pack(pady=5)

        rest_card = self.create_setting_card(scrollable_frame, "üõë BREAK SETTINGS", 1)
        tk.Label(rest_card, text="Break Duration:",
                 font=('Arial', 10, 'bold'), bg='#2c3e50', fg='white').pack(anchor='w', pady=(10, 5))
        rest_time_frame = tk.Frame(rest_card, bg='#2c3e50')
        rest_time_frame.pack(fill='x', padx=10, pady=5)
        rest_value_frame = tk.Frame(rest_time_frame, bg='#2c3e50')
        rest_value_frame.pack(side=tk.LEFT)
        tk.Label(rest_value_frame, text="Duration:", font=('Arial', 9), bg='#2c3e50', fg='white').pack(anchor='w')
        rest_scale = tk.Scale(rest_value_frame, from_=1, to=60, orient=tk.HORIZONTAL,
                              variable=self.rest_value_var, length=200, bg='#2c3e50', fg='white',
                              highlightthickness=0, sliderlength=20)
        rest_scale.pack(fill='x', pady=5)
        rest_entry = tk.Entry(rest_value_frame, textvariable=self.rest_value_var, width=5, font=('Arial', 10))
        rest_entry.pack(pady=5)
        rest_unit_frame = tk.Frame(rest_time_frame, bg='#2c3e50')
        rest_unit_frame.pack(side=tk.RIGHT, padx=20)
        tk.Label(rest_unit_frame, text="Unit:", font=('Arial', 9), bg='#2c3e50', fg='white').pack(anchor='w')
        rest_unit_combo = ttk.Combobox(rest_unit_frame, textvariable=self.rest_unit_var,
                                       values=["seconds", "minutes", "hours"], state="readonly", width=10)
        rest_unit_combo.pack(pady=5)

        prep_card = self.create_setting_card(scrollable_frame, "‚è± PREPARATION SETTINGS", 2)
        tk.Label(prep_card, text="Preparation Time:",
                 font=('Arial', 10, 'bold'), bg='#2c3e50', fg='white').pack(anchor='w', pady=(10, 5))
        prep_time_frame = tk.Frame(prep_card, bg='#2c3e50')
        prep_time_frame.pack(fill='x', padx=10, pady=5)
        prep_value_frame = tk.Frame(prep_time_frame, bg='#2c3e50')
        prep_value_frame.pack(side=tk.LEFT)
        tk.Label(prep_value_frame, text="Duration:", font=('Arial', 9), bg='#2c3e50', fg='white').pack(anchor='w')
        prep_scale = tk.Scale(prep_value_frame, from_=1, to=300, orient=tk.HORIZONTAL,
                              variable=self.prep_value_var, length=200, bg='#2c3e50', fg='white',
                              highlightthickness=0, sliderlength=20)
        prep_scale.set(10)
        prep_scale.pack(fill='x', pady=5)
        prep_entry = tk.Entry(prep_value_frame, textvariable=self.prep_value_var, width=5, font=('Arial', 10))
        prep_entry.pack(pady=5)
        prep_unit_frame = tk.Frame(prep_time_frame, bg='#2c3e50')
        prep_unit_frame.pack(side=tk.RIGHT, padx=20)
        tk.Label(prep_unit_frame, text="Unit:", font=('Arial', 9), bg='#2c3e50', fg='white').pack(anchor='w')
        prep_unit_combo = ttk.Combobox(prep_unit_frame, textvariable=self.prep_unit_var,
                                       values=["seconds", "minutes", "hours"], state="readonly", width=10)
        prep_unit_combo.pack(pady=5)

        camera_card = self.create_setting_card(scrollable_frame, "üì∑ CAMERA SETTINGS", 3)
        cam_frame = tk.Frame(camera_card, bg='#2c3e50')
        cam_frame.pack(fill='x', padx=10, pady=5)
        tk.Label(cam_frame, text="Camera Port:", font=('Arial', 10), bg='#2c3e50', fg='white').pack(side=tk.LEFT)
        self.camera_var = tk.StringVar(value="0")
        camera_combo = ttk.Combobox(cam_frame, textvariable=self.camera_var,
                                   values=["0", "1", "2", "3"], width=10)
        camera_combo.pack(side=tk.LEFT, padx=10)

        detection_card = self.create_setting_card(scrollable_frame, "üë§ FACE DETECTION SETTINGS", 4)
        scale_frame = tk.Frame(detection_card, bg='#2c3e50')
        scale_frame.pack(fill='x', padx=10, pady=5)
        tk.Label(scale_frame, text="Detection Sensitivity:", font=('Arial', 10), bg='#2c3e50', fg='white').pack(side=tk.LEFT)
        self.scale_var = tk.StringVar(value="1.1")
        scale_combo = ttk.Combobox(scale_frame, textvariable=self.scale_var,
                                  values=["1.05", "1.1", "1.15", "1.2", "1.25"], width=10)
        scale_combo.pack(side=tk.LEFT, padx=10)
        neighbors_frame = tk.Frame(detection_card, bg='#2c3e50')
        neighbors_frame.pack(fill='x', padx=10, pady=5)
        tk.Label(neighbors_frame, text="Detection Accuracy:", font=('Arial', 10), bg='#2c3e50', fg='white').pack(side=tk.LEFT)
        self.neighbors_var = tk.StringVar(value="5")
        neighbors_combo = ttk.Combobox(neighbors_frame, textvariable=self.neighbors_var,
                                      values=["3", "4", "5", "6", "7"], width=10)
        neighbors_combo.pack(side=tk.LEFT, padx=10)

        viz_card = self.create_setting_card(scrollable_frame, "üëÅ VISUALIZATION", 5)
        self.bbox_var = tk.BooleanVar(value=True)
        bbox_check = tk.Checkbutton(viz_card, text="Show Face Detection Box",
                                   variable=self.bbox_var, bg='#2c3e50', fg='white',
                                   selectcolor='#34495e', font=('Arial', 10))
        bbox_check.pack(anchor='w', padx=10, pady=10)

        preview_card = self.create_setting_card(scrollable_frame, "üìä SETTINGS PREVIEW", 6)
        self.preview_label = tk.Label(preview_card, text="", font=('Arial', 10),
                                     bg='#2c3e50', fg='#3498db', justify=tk.LEFT)
        self.preview_label.pack(padx=10, pady=10)

        try:
            self.work_value_var.trace_add('write', self.update_preview)
            self.work_unit_var.trace_add('write', self.update_preview)
            self.rest_value_var.trace_add('write', self.update_preview)
            self.rest_unit_var.trace_add('write', self.update_preview)
            self.prep_value_var.trace_add('write', self.update_preview)
            self.prep_unit_var.trace_add('write', self.update_preview)
        except Exception:
            try:
                self.work_value_var.trace('w', self.update_preview)
            except Exception:
                pass

        self.update_preview()

    def update_preview(self, *args):
        try:
            work_value = int(self.work_value_var.get())
            work_unit = self.work_unit_var.get()
            rest_value = int(self.rest_value_var.get())
            rest_unit = self.rest_unit_var.get()
            prep_value = int(self.prep_value_var.get())
            prep_unit = self.prep_unit_var.get()
            work_sec = self.convert_to_seconds(work_value, work_unit)
            rest_sec = self.convert_to_seconds(rest_value, rest_unit)
            prep_sec = self.convert_to_seconds(prep_value, prep_unit)
            preview = f"‚è∞ WORK: {work_value} {work_unit} ({work_sec} seconds)\n"
            preview += f"üõë BREAK: {rest_value} {rest_unit} ({rest_sec} seconds)\n"
            preview += f"‚è± PREP: {prep_value} {prep_unit} ({prep_sec} seconds)\n"
            preview += f"üîÑ TOTAL CYCLE: {work_sec + rest_sec + prep_sec} seconds"
            self.preview_label.config(text=preview)
        except Exception:
            self.preview_label.config(text="‚ö† Please check all settings are valid")

    def convert_to_seconds(self, value, unit):
        if unit == "seconds":
            return int(value)
        elif unit == "minutes":
            return int(value) * 60
        elif unit == "hours":
            return int(value) * 3600
        return int(value)

    def create_setting_card(self, parent, title, index):
        card = tk.Frame(parent, bg='#2c3e50', relief='raised', bd=1)
        card.pack(fill='x', pady=5)
        header = tk.Frame(card, bg='#34495e')
        header.pack(fill='x', pady=(5, 0))
        tk.Label(header, text=title, font=('Arial', 11, 'bold'),
                 bg='#34495e', fg='white').pack(side=tk.LEFT, padx=10, pady=5)
        return card

    def setup_status_panel(self, parent):
        status_frame = tk.Frame(parent, bg='#2c3e50', relief='sunken', bd=1)
        status_frame.pack(fill='x', pady=(20, 0))
        status_content = tk.Frame(status_frame, bg='#2c3e50')
        status_content.pack(fill='x', padx=15, pady=10)
        info_frame = tk.Frame(status_content, bg='#2c3e50')
        info_frame.pack(side=tk.LEFT, fill='x', expand=True)
        self.status_label = tk.Label(info_frame, text="üü¢ SYSTEM READY",
                                    font=('Arial', 11, 'bold'), bg='#2c3e50', fg='#2ecc71')
        self.status_label.pack(anchor='w')
        self.details_label = tk.Label(info_frame, text="Select a profile and click START",
                                      font=('Arial', 9), bg='#2c3e50', fg='#bdc3c7')
        self.details_label.pack(anchor='w')
        start_btn = tk.Button(status_content, text="üöÄ START MONITORING",
                              command=self.start_application,
                              font=('Arial', 12, 'bold'), bg='#27ae60', fg='white',
                              width=20, height=1, relief='raised', bd=3)
        start_btn.pack(side=tk.RIGHT)
        self.update_status_display()

    def update_status_display(self):
        try:
            notebook = self.root.winfo_children()[0].winfo_children()[1]
            current_tab = notebook.index(notebook.select())
        except Exception:
            current_tab = 0
        if current_tab == 0:
            preset = self.get_selected_preset()
            if preset:
                work_unit_symbol = "m" if preset["work_unit"] == "minutes" else "h" if preset["work_unit"] == "hours" else "s"
                rest_unit_symbol = "m" if preset["rest_unit"] == "minutes" else "h" if preset["rest_unit"] == "hours" else "s"
                details = f"Profile: {preset['work']}{work_unit_symbol} work, {preset['rest']}{rest_unit_symbol} break"
                self.details_label.config(text=details)
        else:
            try:
                work_value = self.work_value_var.get()
                work_unit = self.work_unit_var.get()
                rest_value = self.rest_value_var.get()
                rest_unit = self.rest_unit_var.get()
                details = f"Custom: {work_value} {work_unit} work, {rest_value} {rest_unit} break"
                self.details_label.config(text=details)
            except Exception:
                pass

    def show_preset_details(self, preset):
        details = f"üü¢ {preset['name']} Profile Selected"
        self.status_label.config(text=details)
        self.update_status_display()

    def get_selected_preset(self):
        presets = {
            "‚ö° QUICK FOCUS": {"work": 25, "rest": 5, "prep": 1, "work_unit": "minutes", "rest_unit": "minutes"},
            "üíº STANDARD WORK": {"work": 45, "rest": 10, "prep": 2, "work_unit": "minutes", "rest_unit": "minutes"},
            "üöÄ DEEP WORK": {"work": 50, "rest": 10, "prep": 2, "work_unit": "minutes", "rest_unit": "minutes"},
            "üéØ POMODORO PRO": {"work": 25, "rest": 5, "prep": 1, "work_unit": "minutes", "rest_unit": "minutes"},
            "üìä LONG SESSION": {"work": 90, "rest": 15, "prep": 3, "work_unit": "minutes", "rest_unit": "minutes"}
        }
        return presets.get(self.preset_var.get())

    def start_application(self):
        try:
            notebook = self.root.winfo_children()[0].winfo_children()[1]
            current_tab = notebook.index(notebook.select())
        except Exception:
            current_tab = 0

        if current_tab == 0:
            preset = self.get_selected_preset()
            if not preset:
                messagebox.showerror("Error", "Please select a work profile!")
                return
            work_sec = self.convert_to_seconds(preset["work"], preset["work_unit"])
            rest_sec = self.convert_to_seconds(preset["rest"], preset["rest_unit"])
            prep_sec = self.convert_to_seconds(preset["prep"], preset.get("prep_unit", "minutes"))
            camera_index = 0
            scale_factor = 1.1
            min_neighbors = 5
            show_bbox = True
        else:
            try:
                work_sec = self.convert_to_seconds(int(self.work_value_var.get()), self.work_unit_var.get())
                rest_sec = self.convert_to_seconds(int(self.rest_value_var.get()), self.rest_unit_var.get())
                prep_sec = self.convert_to_seconds(int(self.prep_value_var.get()), self.prep_unit_var.get())
                camera_index = int(self.camera_var.get())
                scale_factor = float(self.scale_var.get())
                min_neighbors = int(self.neighbors_var.get())
                show_bbox = self.bbox_var.get()
            except Exception:
                messagebox.showerror("Error", "Please check all settings are valid!")
                return

        self.config = {
            'waktu_kerja': work_sec,
            'waktu_istirahat': rest_sec,
            'waktu_persiapan': prep_sec,
            'camera_index': camera_index,
            'scale_factor': scale_factor,
            'min_neighbors': min_neighbors,
            'show_bbox': show_bbox,
        }
        self.root.destroy()

    def get_config(self):
        return self.config

# ---------------------------------------
# MONITORING WINDOW (POPUPS AS SUBPROCESS)
# ---------------------------------------
class MonitoringWindow:
    def _init_(self, monitoring_system):
        self.monitoring_system = monitoring_system
        self.root = tk.Toplevel()
        self.root.title("Work Monitoring - Live Camera")
        self.root.geometry("800x600")
        self.root.resizable(True, True)
        self.root.configure(bg='#1e2a38')
        self.root.attributes('-topmost', True)

        self.camera_display_width = 600
        self.camera_display_height = 400
        self.camera_frame = None

        self.ear_threshold_var = tk.StringVar(value="0.20")
        self.mar_threshold_var = tk.StringVar(value="0.60")
        self.head_angle_threshold_var = tk.StringVar(value="15")

        # Instead of Toplevel popups, we'll spawn independent subprocesses for popups
        self._drowsy_proc = None
        self._break_proc = None
        self._popup_helper_path = None  # path to helper script written to temp

        self._break_popup_shown = False

        self.setup_ui()

    def setup_ui(self):
        main_container = tk.Frame(self.root, bg='#1e2a38')
        main_container.pack(fill='both', expand=True, padx=10, pady=10)

        header_frame = tk.Frame(main_container, bg='#2c3e50', height=50)
        header_frame.pack(fill='x', pady=(0, 10))
        header_frame.pack_propagate(False)
        tk.Label(header_frame, text="üì∑ WORK MONITORING - LIVE CAMERA",
                 font=('Arial', 14, 'bold'), bg='#2c3e50', fg='white').pack(expand=True, pady=15)

        content_frame = tk.Frame(main_container, bg='#1e2a38')
        content_frame.pack(fill='both', expand=True)

        camera_frame = tk.Frame(content_frame, bg='#1e2a38')
        camera_frame.pack(side=tk.LEFT, fill='both', expand=True, padx=(0, 10))

        cam_container = tk.Frame(camera_frame, bg='#2c3e50', relief='sunken', bd=2)
        cam_container.pack(fill='both', expand=True)

        self.camera_display = tk.Label(cam_container, text="Camera Feed\nInitializing...",
                                      bg='#1e2a38', fg='#7f8c8d', font=('Arial', 12),
                                      justify=tk.CENTER)
        self.camera_display.pack(expand=True, fill='both', padx=10, pady=10)

        settings_frame = tk.Frame(content_frame, bg='#2c3e50', width=250)
        settings_frame.pack(side=tk.RIGHT, fill='y')
        settings_frame.pack_propagate(False)

        drowsy_settings = tk.Frame(settings_frame, bg='#34495e', relief='raised', bd=2)
        drowsy_settings.pack(fill='x', padx=10, pady=10)

        tk.Label(drowsy_settings, text="üò¥ DROWSINESS SETTINGS",
                 font=('Arial', 12, 'bold'), bg='#34495e', fg='#f39c12').pack(pady=8)

        ear_frame = tk.Frame(drowsy_settings, bg='#34495e')
        ear_frame.pack(fill='x', padx=10, pady=5)
        tk.Label(ear_frame, text="EAR Threshold:", font=('Arial', 10), bg='#34495e', fg='white').pack(side=tk.LEFT)
        ear_combo = ttk.Combobox(ear_frame, textvariable=self.ear_threshold_var,
                                 values=["0.20", "0.23", "0.25", "0.27", "0.30"],
                                 state="readonly", width=8)
        ear_combo.pack(side=tk.RIGHT, padx=5)

        mar_frame = tk.Frame(drowsy_settings, bg='#34495e')
        mar_frame.pack(fill='x', padx=10, pady=5)
        tk.Label(mar_frame, text="MAR Threshold:", font=('Arial', 10), bg='#34495e', fg='white').pack(side=tk.LEFT)
        mar_combo = ttk.Combobox(mar_frame, textvariable=self.mar_threshold_var,
                                 values=["0.50", "0.60", "0.70", "0.80"],
                                 state="readonly", width=8)
        mar_combo.pack(side=tk.RIGHT, padx=5)

        head_frame = tk.Frame(drowsy_settings, bg='#34495e')
        head_frame.pack(fill='x', padx=10, pady=5)
        tk.Label(head_frame, text="Head Angle (¬∞):", font=('Arial', 10), bg='#34495e', fg='white').pack(side=tk.LEFT)
        head_combo = ttk.Combobox(head_frame, textvariable=self.head_angle_threshold_var,
                                  values=["10", "15", "20", "25", "30"], state="readonly", width=8)
        head_combo.pack(side=tk.RIGHT, padx=5)

        status_info = tk.Frame(settings_frame, bg='#34495e', relief='raised', bd=2)
        status_info.pack(fill='x', padx=10, pady=10)
        tk.Label(status_info, text="üìä SYSTEM STATUS", font=('Arial', 12, 'bold'),
                 bg='#34495e', fg='#3498db').pack(pady=8)
        self.status_label = tk.Label(status_info, text="üü¢ SYSTEM READY",
                                     font=('Arial', 11, 'bold'), bg='#34495e', fg='#2ecc71')
        self.status_label.pack(pady=5)
        self.time_label = tk.Label(status_info, text="Work Time: 0s / 0s",
                                   font=('Arial', 10), bg='#34495e', fg='white')
        self.time_label.pack(pady=2)
        self.face_label = tk.Label(status_info, text="Faces: 0",
                                   font=('Arial', 10), bg='#34495e', fg='white')
        self.face_label.pack(pady=2)

        instructions = tk.Frame(settings_frame, bg='#34495e', relief='raised', bd=2)
        instructions.pack(fill='x', padx=10, pady=10)
        tk.Label(instructions, text="üí° INSTRUCTIONS", font=('Arial', 12, 'bold'),
                 bg='#34495e', fg='#9b59b6').pack(pady=8)
        instruction_text = ("‚Ä¢ During WORK: Drowsiness detection active\n"
                            "‚Ä¢ During BREAK: Move away from camera\n"
                            "‚Ä¢ Popups will alert you of issues\n"
                            "‚Ä¢ Window can be minimized\n"
                            "‚Ä¢ Always stays on top")
        tk.Label(instructions, text=instruction_text, font=('Arial', 9),
                 bg='#34495e', fg='white', justify=tk.LEFT).pack(padx=10, pady=5)

    def update_camera_feed(self, frame):
        try:
            if frame is None:
                return
            frame_resized = cv2.resize(frame, (self.camera_display_width, self.camera_display_height))
            frame_rgb = cv2.cvtColor(frame_resized, cv2.COLOR_BGR2RGB)
            img = Image.fromarray(frame_rgb)
            photo = ImageTk.PhotoImage(image=img)
            self.camera_display.config(image=photo, text="")
            self.camera_display.image = photo
        except Exception:
            traceback.print_exc()

    def update_status(self, status_text, time_text, face_count):
        try:
            self.status_label.config(text=status_text)
            self.time_label.config(text=time_text)
            self.face_label.config(text=f"Faces: {face_count}")
        except Exception:
            pass

    # ----------------------------
    # Popup helper: create an external script and spawn subprocess
    # ----------------------------
    def _ensure_popup_helper(self):
        """Write helper popup script once to temp file and store path."""
        if self._popup_helper_path and os.path.exists(self._popup_helper_path):
            return self._popup_helper_path

        helper_code = r'''
import tkinter as tk
import argparse
import sys

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--title", default="Popup")
    parser.add_argument("--lines", nargs="*", default=[])
    parser.add_argument("--bg", default="#ffffff")
    parser.add_argument("--w", type=int, default=400)
    parser.add_argument("--h", type=int, default=200)
    parser.add_argument("--disable_close", action="store_true")
    args = parser.parse_args()

    root = tk.Tk()
    root.title(args.title)
    root.configure(bg=args.bg)
    w = args.w
    h = args.h
    sw = root.winfo_screenwidth()
    sh = root.winfo_screenheight()
    x = (sw - w) // 2
    y = (sh - h) // 2
    root.geometry(f"{w}x{h}+{x}+{y}")
    root.attributes('-topmost', True)
    if args.disable_close:
        try:
            root.protocol("WM_DELETE_WINDOW", lambda: None)
        except Exception:
            pass

    for line in args.lines:
        lbl = tk.Label(root, text=line, bg=args.bg, fg='white', font=('Arial', 14), justify=tk.CENTER)
        lbl.pack(expand=True)

    try:
        root.mainloop()
    except KeyboardInterrupt:
        pass

if _name_ == "_main_":
    main()
'''
        # write to temp file
        tf = tempfile.NamedTemporaryFile(delete=False, suffix=".py", prefix="wm_popup_")
        tf.write(helper_code.encode('utf-8'))
        tf.close()
        self._popup_helper_path = tf.name
        return self._popup_helper_path

    def _spawn_popup_process(self, title, lines, bg, w, h, disable_close=False):
        """Spawn a subprocess to show popup. Return subprocess.Popen object."""
        helper = self._ensure_popup_helper()
        cmd = [sys.executable, helper, '--title', title, '--bg', bg, '--w', str(w), '--h', str(h)]
        if disable_close:
            cmd.append('--disable_close')
        # pass lines
        for line in lines:
            cmd.append('--lines')
            cmd.append(line)
        # Start detached so it's independent; on Windows, creationflags helps but not necessary for basic use
        try:
            # On Windows, DETACHED_PROCESS could be used, but Popen normal start is fine.
            proc = subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return proc
        except Exception:
            traceback.print_exc()
            return None

    def _terminate_proc(self, proc):
        try:
            if proc and proc.poll() is None:
                proc.terminate()
                # give it short time, then kill if still alive
                try:
                    proc.wait(timeout=1.0)
                except Exception:
                    proc.kill()
        except Exception:
            pass

    # ---- Public popup API used by monitoring system ----
    def show_drowsy_popup(self):
        """Launch independent popup process for drowsiness (auto-hide when terminated)."""
        try:
            if self._drowsy_proc and self._drowsy_proc.poll() is None:
                # already running; nothing to do
                return
            title = "‚ö† DROWSINESS ALERT"
            lines = ["‚ö† PERINGATAN KANTUK ‚ö†", "ANDA TERDETEKSI MENGANTUK!", "Segera istirahat sejenak dan konsentrasi kembali"]
            bg = "#e74c3c"
            proc = self._spawn_popup_process(title, lines, bg, w=420, h=180, disable_close=False)
            self._drowsy_proc = proc
        except Exception:
            traceback.print_exc()

    def hide_drowsy_popup(self):
        try:
            if self._drowsy_proc:
                self._terminate_proc(self._drowsy_proc)
                self._drowsy_proc = None
        except Exception:
            pass

    def show_break_popup(self):
        """Launch independent popup process for break; disable manual close (persistent until main stops it)."""
        try:
            if self._break_proc and self._break_proc.poll() is None:
                return
            title = "üõë WAKTU ISTIRAHAT üõë"
            lines = ["üõë WAKTU ISTIRAHAT üõë", "Dear Pengguna,", "Manfaatkan dan Maksimalkan istirahat anda", "Jauhkan diri dari komputer dan lakukan peregangan"]
            bg = "#f39c12"
            proc = self._spawn_popup_process(title, lines, bg, w=560, h=220, disable_close=True)
            self._break_proc = proc
            self._break_popup_shown = True
        except Exception:
            traceback.print_exc()

    def hide_break_popup(self):
        try:
            if self._break_proc:
                self._terminate_proc(self._break_proc)
                self._break_proc = None
            self._break_popup_shown = False
        except Exception:
            pass

    def get_drowsiness_thresholds(self):
        try:
            return {
                'ear': float(self.ear_threshold_var.get()),
                'mar': float(self.mar_threshold_var.get()),
                'head_angle': float(self.head_angle_threshold_var.get())
            }
        except Exception:
            return {'ear': 0.2, 'mar': 0.6, 'head_angle': 15.0}

# ---------------------------------------
# MONITORING SYSTEM (LOGIC PRESERVED)
# ---------------------------------------
class WorkMonitoringSystem:
    def _init_(self, config, monitoring_window=None):
        self.config = config
        self.monitoring_window = monitoring_window
        self.face_cascade = self.load_cascade()
        self.cap = None
        self.state = "KERJA"
        self.timer_start = None
        self.elapsed_time = 0
        self.accumulated_work_time = 0
        self.face_detected = False
        self.face_detected_consecutive = 0
        self.last_face_check_time = None
        self.running = True
        self.current_frame = None

        self.mp_face_mesh = mp.solutions.face_mesh
        self.face_mesh = self.mp_face_mesh.FaceMesh(
            max_num_faces=1,
            refine_landmarks=True,
            min_detection_confidence=0.5,
            min_tracking_confidence=0.5
        )

        try:
            pygame.mixer.init(frequency=22050, size=-16, channels=2, buffer=512)
        except Exception:
            print("[WARNING] pygame.mixer.init failed; audio may not work")
        self.alarm_sound = None
        self.is_alarm_playing = False
        self.drowsy_frame_count = 0

        try:
            audio_path = "1.mp3"
            if os.path.exists(audio_path):
                self.alarm_sound = pygame.mixer.Sound(audio_path)
                print(f"[SUCCESS] Audio alarm loaded: {audio_path}")
            else:
                print(f"[INFO] Audio file not found: {audio_path} (alarm disabled)")
        except Exception as e:
            print(f"[ERROR] Failed to load audio: {e}")

        self.is_drowsy = False
        self.break_popup_shown = False

    def load_cascade(self):
        path = cv2.data.haarcascades + "haarcascade_frontalface_default.xml"
        face_cascade = cv2.CascadeClassifier(path)
        if face_cascade.empty():
            raise RuntimeError("Gagal memuat Haar Cascade.")
        return face_cascade

    def detect_faces(self, frame):
        try:
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            gray = cv2.equalizeHist(gray)
            faces = self.face_cascade.detectMultiScale(
                gray,
                scaleFactor=self.config.get('scale_factor', 1.1),
                minNeighbors=self.config.get('min_neighbors', 5),
                minSize=(30, 30)
            )
            return faces
        except Exception:
            return []

    def draw_faces(self, frame, faces):
        for (x, y, w, h) in faces:
            if self.config.get('show_bbox', True):
                cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)
        return frame

    def calculate_ear(self, landmarks, eye_indices):
        try:
            eye_points = []
            for idx in eye_indices:
                p = landmarks[idx]
                eye_points.append([p.x, p.y])
            eye_points = np.array(eye_points)
            A = dist.euclidean(eye_points[1], eye_points[5])
            B = dist.euclidean(eye_points[2], eye_points[4])
            C = dist.euclidean(eye_points[0], eye_points[3])
            if C == 0:
                return 0.0
            ear = (A + B) / (2.0 * C)
            return ear
        except Exception:
            return 0.3

    def calculate_mar(self, landmarks):
        try:
            mouth_top = landmarks[13]
            mouth_bottom = landmarks[14]
            mouth_left = landmarks[61]
            mouth_right = landmarks[291]
            vertical = dist.euclidean([mouth_top.x, mouth_top.y], [mouth_bottom.x, mouth_bottom.y])
            horizontal = dist.euclidean([mouth_left.x, mouth_left.y], [mouth_right.x, mouth_right.y])
            if horizontal == 0:
                return 0.0
            mar = vertical / horizontal
            return mar
        except Exception:
            return 0.0

    def calculate_head_pose(self, landmarks, frame_shape):
        try:
            img_h, img_w = frame_shape[:2]
            model_points = np.array([
                (0.0, 0.0, 0.0),
                (0.0, -330.0, -65.0),
                (-225.0, 170.0, -135.0),
                (225.0, 170.0, -135.0),
                (-150.0, -150.0, -125.0),
                (150.0, -150.0, -125.0)
            ])
            image_points = np.array([
                (landmarks[1].x * img_w, landmarks[1].y * img_h),
                (landmarks[152].x * img_w, landmarks[152].y * img_h),
                (landmarks[263].x * img_w, landmarks[263].y * img_h),
                (landmarks[33].x * img_w, landmarks[33].y * img_h),
                (landmarks[287].x * img_w, landmarks[287].y * img_h),
                (landmarks[57].x * img_w, landmarks[57].y * img_h)
            ], dtype="double")
            focal_length = img_w
            center = (img_w / 2, img_h / 2)
            camera_matrix = np.array([
                [focal_length, 0, center[0]],
                [0, focal_length, center[1]],
                [0, 0, 1]
            ], dtype="double")
            dist_coeffs = np.zeros((4, 1))
            success, rotation_vector, translation_vector = cv2.solvePnP(
                model_points, image_points, camera_matrix, dist_coeffs,
                flags=cv2.SOLVEPNP_ITERATIVE
            )
            rotation_mat, _ = cv2.Rodrigues(rotation_vector)
            pose_mat = cv2.hconcat((rotation_mat, translation_vector))
            _, _, _, _, _, _, euler_angles = cv2.decomposeProjectionMatrix(pose_mat)
            pitch, yaw, roll = euler_angles.flatten()[:3]
            return abs(pitch), abs(yaw), abs(roll)
        except Exception:
            return 0.0, 0.0, 0.0

    def detect_drowsiness(self, frame):
        if self.state != "KERJA":
            self.stop_alarm()
            if self.monitoring_window:
                try:
                    self.monitoring_window.hide_drowsy_popup()
                except Exception:
                    pass
            return frame, False

        thresholds = {'ear': 0.20, 'mar': 0.60, 'head_angle': 15}
        if self.monitoring_window:
            try:
                thresholds = self.monitoring_window.get_drowsiness_thresholds()
            except Exception:
                pass

        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(rgb_frame)
        is_drowsy = False

        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                h, w, c = frame.shape
                for landmark in face_landmarks.landmark:
                    x = int(landmark.x * w)
                    y = int(landmark.y * h)
                    cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)
                LEFT_EYE = [362, 385, 387, 263, 373, 380]
                RIGHT_EYE = [33, 160, 158, 133, 153, 144]
                left_ear = self.calculate_ear(face_landmarks.landmark, LEFT_EYE)
                right_ear = self.calculate_ear(face_landmarks.landmark, RIGHT_EYE)
                avg_ear = (left_ear + right_ear) / 2.0
                mar = self.calculate_mar(face_landmarks.landmark)
                pitch, yaw, roll = self.calculate_head_pose(face_landmarks.landmark, frame.shape)
                cv2.putText(frame, f"EAR: {avg_ear:.2f}", (10, h - 90),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
                cv2.putText(frame, f"MAR: {mar:.2f}", (10, h - 60),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
                cv2.putText(frame, f"Head: P={pitch:.0f} Y={yaw:.0f}", (10, h - 30),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
                if avg_ear < thresholds['ear']:
                    cv2.putText(frame, "EYES CLOSED!", (w - 200, 30),
                               cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
                    is_drowsy = True
                if mar > thresholds['mar']:
                    cv2.putText(frame, "YAWNING!", (w - 200, 60),
                               cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
                    is_drowsy = True
                if yaw > thresholds['head_angle'] or pitch > thresholds['head_angle']:
                    cv2.putText(frame, "HEAD TILTED!", (w - 200, 90),
                               cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
                    is_drowsy = True
                if is_drowsy:
                    cv2.putText(frame, "DROWSY DETECTED!", (w // 2 - 150, 30),
                               cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 0, 255), 3)

        if is_drowsy:
            self.drowsy_frame_count += 1
            if self.drowsy_frame_count >= 3:
                self.play_alarm()
                if self.monitoring_window:
                    try:
                        # Launch independent popup process (does NOT restore main window)
                        self.monitoring_window.show_drowsy_popup()
                    except Exception:
                        pass
        else:
            if self.drowsy_frame_count > 0:
                self.drowsy_frame_count = 0
                self.stop_alarm()
                if self.monitoring_window:
                    try:
                        self.monitoring_window.hide_drowsy_popup()
                    except Exception:
                        pass

        return frame, is_drowsy

    def play_alarm(self):
        if self.alarm_sound is None:
            return
        try:
            if not pygame.mixer.get_busy() or not self.is_alarm_playing:
                self.alarm_sound.play(loops=-1)
                self.is_alarm_playing = True
        except Exception as e:
            print(f"[ERROR] Failed to play alarm: {e}")
            self.is_alarm_playing = False

    def stop_alarm(self):
        if self.alarm_sound is None:
            self.is_alarm_playing = False
            return
        try:
            if self.is_alarm_playing or pygame.mixer.get_busy():
                self.alarm_sound.stop()
                self.is_alarm_playing = False
        except Exception as e:
            print(f"[ERROR] Failed to stop alarm: {e}")
            self.is_alarm_playing = False

    def update_face_consecutive_counter(self, faces):
        current_time = time.time()
        if len(faces) > 0:
            if self.last_face_check_time is None:
                self.face_detected_consecutive = 0
                self.last_face_check_time = current_time
            else:
                time_diff = current_time - self.last_face_check_time
                self.face_detected_consecutive += time_diff
                self.last_face_check_time = current_time
        else:
            self.face_detected_consecutive = 0
            self.last_face_check_time = None

    def draw_ui(self, frame, faces):
        height, width = frame.shape[:2]
        self.face_detected = len(faces) > 0
        overlay = frame.copy()
        cv2.rectangle(overlay, (0, 0), (width, 100), (0, 0, 0), -1)
        cv2.addWeighted(overlay, 0.7, frame, 0.3, 0, frame)
        if self.timer_start is None:
            self.timer_start = time.time()
        self.elapsed_time = time.time() - self.timer_start
        if self.state == "ISTIRAHAT":
            self.update_face_consecutive_counter(faces)
        should_shutdown = False
        status_text = ""
        time_text = ""
        if self.state == "KERJA":
            should_shutdown, status_text, time_text = self.handle_state_kerja(frame, faces)
        elif self.state == "ISTIRAHAT":
            should_shutdown, status_text, time_text = self.handle_state_istirahat(frame, faces)
        elif self.state == "PERSIAPAN":
            should_shutdown, status_text, time_text = self.handle_state_persiapan(frame, faces)
        if self.monitoring_window:
            try:
                self.monitoring_window.update_status(status_text, time_text, len(faces))
            except Exception:
                pass
        timestamp = datetime.now().strftime("%H:%M:%S")
        cv2.putText(frame, f"Time: {timestamp}", (10, height - 20),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
        return frame, should_shutdown

    def handle_state_kerja(self, frame, faces):
        cv2.putText(frame, "STATUS: WORKING", (10, 30),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
        status_text = "üü¢ WORKING"
        if self.face_detected:
            current_time = time.time()
            time_delta = current_time - self.timer_start
            self.accumulated_work_time += time_delta
            self.timer_start = current_time
            cv2.putText(frame, f"Work Time: {int(self.accumulated_work_time)}s / {self.config['waktu_kerja']}s",
                       (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
            cv2.putText(frame, f"Faces: {len(faces)} - Timer Running", (10, 90),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
            time_text = f"Work: {int(self.accumulated_work_time)}s / {self.config['waktu_kerja']}s"
        else:
            self.timer_start = time.time()
            cv2.putText(frame, f"Work Time: {int(self.accumulated_work_time)}s / {self.config['waktu_kerja']}s",
                       (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
            cv2.putText(frame, "PAUSED: No Face Detected!", (10, 90),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 165, 255), 2)
            time_text = f"Work: {int(self.accumulated_work_time)}s / {self.config['waktu_kerja']}s ‚è∏"
        if self.accumulated_work_time >= self.config['waktu_kerja']:
            print(f"[INFO] Work time completed. Entering break mode...")
            self.state = "ISTIRAHAT"
            self.timer_start = time.time()
            self.accumulated_work_time = 0
            self.face_detected_consecutive = 0
            self.last_face_check_time = None
            self.break_popup_shown = False
        return False, status_text, time_text

    def handle_state_istirahat(self, frame, faces):
        cv2.putText(frame, "STATUS: BREAK TIME", (10, 30),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 165, 0), 2)
        cv2.putText(frame, f"Break Time: {int(self.elapsed_time)}s / {self.config['waktu_istirahat']}s",
                   (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
        status_text = "üü° BREAK TIME"
        time_text = f"Break: {int(self.elapsed_time)}s / {self.config['waktu_istirahat']}s"
        if self.face_detected:
            consecutive_sec = int(self.face_detected_consecutive)
            if consecutive_sec >= 6 and not self.break_popup_shown:
                if self.monitoring_window:
                    try:
                        # launch independent break popup (persistent)
                        self.monitoring_window.show_break_popup()
                    except Exception:
                        pass
                self.break_popup_shown = True
            if consecutive_sec >= 6:
                cv2.putText(frame, f"WARNING: REST PROPERLY! ({consecutive_sec}s)", (10, 90),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)
            else:
                cv2.putText(frame, f"Face Detected: {consecutive_sec}s consecutive", (10, 90),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)
        else:
            cv2.putText(frame, "On Break... No Face Detected", (10, 90),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (200, 200, 200), 2)
            self.break_popup_shown = self.break_popup_shown and self.monitoring_window is not None
        if self.elapsed_time >= self.config['waktu_istirahat']:
            print(f"[INFO] Break completed. Entering preparation mode...")
            self.state = "PERSIAPAN"
            self.timer_start = time.time()
            self.face_detected_consecutive = 0
            self.last_face_check_time = None
            if self.monitoring_window:
                try:
                    self.monitoring_window.hide_break_popup()
                except Exception:
                    pass
            self.break_popup_shown = False
        return False, status_text, time_text

    def handle_state_persiapan(self, frame, faces):
        remaining = self.config['waktu_persiapan'] - self.elapsed_time
        cv2.putText(frame, "STATUS: PREPARING TO WORK", (10, 30),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 0, 255), 2)
        cv2.putText(frame, f"Time Remaining: {max(0, int(remaining))}s",
                   (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
        status_text = "üîµ PREPARING"
        time_text = f"Prep: {max(0, int(remaining))}s remaining"
        if self.face_detected:
            cv2.putText(frame, "Face Detected - Ready to Work", (10, 90),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
        else:
            cv2.putText(frame, "Waiting for User Return...", (10, 90),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 165, 0), 2)
        if self.elapsed_time >= self.config['waktu_persiapan']:
            if self.face_detected:
                print("[INFO] User returned. Starting new work cycle...")
                self.state = "KERJA"
                self.timer_start = time.time()
                self.accumulated_work_time = 0
            else:
                print("[INFO] No user after preparation. Closing system...")
                return True, status_text, time_text
        return False, status_text, time_text

    def run(self):
        self.cap = cv2.VideoCapture(self.config['camera_index'])
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
        if not self.cap.isOpened():
            print("[ERROR] Cannot open camera!")
            return
        print(f"[INFO] Monitoring system started")
        print(f"[INFO] Work Time: {self.config['waktu_kerja']}s")
        print(f"[INFO] Break Time: {self.config['waktu_istirahat']}s")
        print(f"[INFO] Preparation Time: {self.config['waktu_persiapan']}s")
        print(f"[INFO] Drowsiness detection active during WORK mode")
        try:
            while self.running:
                ret, frame = self.cap.read()
                if not ret:
                    print("[ERROR] Failed to read frame from camera!")
                    break
                faces = self.detect_faces(frame)
                frame = self.draw_faces(frame, faces)
                frame, is_drowsy = self.detect_drowsiness(frame)
                frame, should_shutdown = self.draw_ui(frame, faces)
                self.current_frame = frame.copy()
                if self.monitoring_window:
                    try:
                        self.monitoring_window.update_camera_feed(self.current_frame)
                    except Exception:
                        pass
                if should_shutdown:
                    print("[INFO] System will shutdown in 3 seconds...")
                    time.sleep(3)
                    self.shutdown()
                    break
                time.sleep(0.033)
        finally:
            try:
                if self.cap:
                    self.cap.release()
            except Exception:
                pass
            try:
                self.face_mesh.close()
            except Exception:
                pass
            self.stop_alarm()
            print("[INFO] Monitoring system stopped.")

    def shutdown(self):
        self.running = False
        self.stop_alarm()
        if self.monitoring_window:
            try:
                # ensure all popups are closed
                self.monitoring_window.hide_drowsy_popup()
                self.monitoring_window.hide_break_popup()
            except Exception:
                pass
            try:
                self.monitoring_window.root.quit()
            except Exception:
                pass

# ---------------------------
# MAIN
# ---------------------------
def main():
    settings_window = ProfessionalSettingsWindow()
    settings_window.root.mainloop()
    config = settings_window.get_config()
    if config is None:
        print("[INFO] Application cancelled")
        return
    monitoring_system = WorkMonitoringSystem(config)
    monitoring_window = MonitoringWindow(monitoring_system)
    monitoring_system.monitoring_window = monitoring_window
    monitor_thread = threading.Thread(target=monitoring_system.run, daemon=True)
    monitor_thread.start()

    def on_closing():
        monitoring_system.shutdown()
        try:
            monitoring_window.root.destroy()
        except Exception:
            pass

    monitoring_window.root.protocol("WM_DELETE_WINDOW", on_closing)
    monitoring_window.root.mainloop()
    print("[INFO] Application closed.")


if _name_ == "_main_":
¬†¬†¬†¬†main()
